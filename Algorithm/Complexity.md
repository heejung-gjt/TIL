## 시간 복잡도
얼마나 빠르게 계산되는지에 대한 계산이다.  실행시간을 예측해보고 효율적인 코드인가를 나타낸다. 복잡도가 낮을수록 효율적인 코드이다
## 공간 복잡도
얼마나 많은 저장 공간이 필요한지에 대한 계산이다. 공간을 미리 확보하는 자료구조에서 중요하다. 복잡도가 낮을수록 효율적인 코드이다    

둘 다 만족시키기는것은 어렵다. ```시간복잡도```를 중심으로 코드를 짜자.
##  Big-O
빅오 표기법은 알고리즘의 성능을 수학적으로 표기해주는 표기법이다. 빅오표기법은 알고리즘의 시간복잡도와 공간 복잡도를 나타내는데 주로 사용된다.    

```O(1)``` 
 입력 데이터의 크기와 상관없이 일정한 시간이 걸리는 알고리즘이다. __데이터가 증가해도 성능에 영향을 거의 주지 않는다.__   

 아래의 코드를 보면  첫번째 배열방이 0인지 확인하는 코드로 인자로 받는 배열값이 얼마나 큰지 상관없이 언제나 일정한 속도로 결과를 반환한다.
```python
def func(n){
    return n[0]==0 ? true:false
}
```   

```O(N)```   
입력데이터의 크기에 비례해서 처리시간이 걸리는 알고리즘이다.   

아래의 코드를 보면  n개의 데이터가 늘어나면 늘어날수록 n번만큼 루프를 도는 for문의 루프횟수도 그만큼 늘어난다
```python
def func(n){
    for i in range(len(n)):
        print(i)
}
```
```O(n^2)```   
입력데이터의 크기에 제곱으로 비례해서 처리시간이 늘어나는 알고리즘이다    

아래의 코드를 보면 n번 루프를 돌리면서 그안에서 또다시  n번 루프를 돌리게 된다. n=2이라고 생각해보자.  i=0일때 j에서 j=0,1만큼 루프를 돌린다. 즉 j에서는 print(0+1),print(0+2),총 2번을 돌리고 다시 i로 올라가게 된다. i=1일때 똑같이 반복하게 되는데 n=2 일때 총 2^2인 4번 수행하게된다.
```python
def func(n){
    for i in range(len(n)):
        for j in range(len(n)):
            print(i+j)
}
```
```O(nm)```   
O(n2)과 비슷하지만 n과 m의 값에 따라서 시간복잡도가 달라진다.   

아래의 코드를 보면 n번 루프를 돌리면서 그 안에 m번 루프를 돌리게 되는데 O(n2)은 무조건 비례해서 증가했지만 O(nm)은 m의 값이 작을수도 있기때문에 따져봐야 한다.
```python
def func(n,m){
    for i in range(len(n)):
        for j in range(len(m)):
            print(i+j)
}
```
```O(n3)```   
루프를 n의 값을 가지고 삼중으로 돌리면 O(n3)의 복잡도가 된다. 처리시간이 급격하게 늘어나는 것을 볼 수 있다
```python
def func(n){
    for i in range(len(n)):
        for j in range(len(n)):
            for k in range(len(n)):
                print(i+j)
}
```
```O(2^n)```   
대표적으로 피보나치 수열이 O(2^n)의 시간복잡도를 가진다   

아래의 코드를 보면 함수를 호출할때마다 전의 숫자와 전전 숫자를 알아내기 위해 2번씩 함수를 다시 호출을 하게 된다. f(5) -> f(4),f(3) 호출 f(4) -> f(3),f(2)호출, f(3) -> f(2),f(1)호출 f(2) -> f(1),f(0)호출.. 총  2^5번 호출하게 된다

```python
def fibo(n){
    if n<3:
        return 1
    else:
        return fibo(n-1) +fibo(n-2)
}
```
- O(log n)
대표적으로 이진검색이 O(log n)의 시간 복잡도를 나타낸다. 한번씩 처리가 진행될때마다 검색해야 하는 데이터양이 절반씩 줄어들때 O(log n)의 복잡도를 가진다    

```O(2n) == O(n)```   
아래의 코드를 보면 for문이 2번 사용되었다. for문을 각각 2번씩 돌려도 n을 처리하는데에는 영향을 주지 않기때문에 O(n)으로 표기한다   
```python
def func(n){
    for i in range(len(n)):
        print(i)
    for i in range(len(n)):
        print(i)
}
```
  

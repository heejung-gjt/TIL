## 배열(Arrays) 과 리스트(List)    

```배열이란```    
같은 종류의 데이터를 효율적으로 관리하고 순차적으로 저장하여 처리하기 위해 사용하는 자료구조이다  
<br>

```배열 특징```         
- 생성될때 크기가 정해진다(정적할당)       

- 인덱스를 활용하여 자료에 빠르게 접근이 가능하다   

- 배열의 모든 아이템들은 똑같은 사이즈를 갖는다.   

- 아이템이 메모리상에 연속적으로 위치해 있다
<br>

```배열 장점```    
- 인덱스로 아이템에 빠르게 접근이 가능하다   

- 아이템의 메모리주소가 연속적이므로 메모리 관리가 편하다    
<br>

```배열 단점```    
- 배열의 길이는 생성될때 정해지기 때문에 변경할 수 없으며 배열의 크기를 변경하고 싶을때마다 새로운 배열을 만들어야 한다(데이터 추가, 삭제 불편)        

- 요소를 삭제하면 배열에 빈 틈이 생겨 메모리가 낭비된다 (실제로는 요소삭제가 불가능)     

<br>

```리스트란```      
파이썬에서 사용되는 자료구조로 배열과 비슷한 기능을 하지만 배열 자료구조와는 다르며 고수준의 기능을 포함한다. 
<br>

```리스트 특징```         
- 생성되는 아이템이 불연속적으로 메모리 공간을 차지한다      

- 포인터를 통해 데이터에 접근한다   

- 인덱스는 단순히 아이템이 몇번째 데이터인가를 의미한다  
<br>

```리스트 장점```    
- 포인터를 통해 데이터에 접근하기 때문에 데이터 삭제,삽입이 용이하다     

- 생성될때 크기가 정해져 있지 않기 때문에(동적할당) 메모리 재사용이 편리하다    
<br>

```리스트 단점```    
- 리스트는 데이터에 직접적인 접근이 불가능하고 몇번째인지 처음부터 찾아야 하므로 검색 성능이 좋지 않다.       

<br>

## Array List implementation

### 구현 조건
- class와 array.array를 이용하여 Array List를 구현한다.
  - 데이터의 타입은 l(signed long)으로 한다.
  - array.array 객체의 메소드는 아래 메소드만을 사용한다.
    - arr[ind](인덱스로 접근), arr[ind:](슬라이싱)
- array.array의 용량(capacity)은 고정되어 있다고 가정한다.
  - 배열의 크기가 부족할 때 마다 2배 길이의 array.array를 새로 생성한다.
- 다음과 같은 리스트 ADT의 연산자를 구현해야 한다.
  - 비어있는 리스트를 생성하는 생성자
  - 리스트가 비어있는지 확인하는 연산자
  - 리스트의 앞에 개체를 삽입(prepending)하는 연산자
  - 리스트의 뒤에 개체를 삽입(appending)하는 연산자
  - 리스트의 첫 머리(head)를 결정하는 연산자
  - 주어진 인덱스에 해당하는 요소에 접근하는 연산자
  - 주어진 인덱스에 새로운 요소를 삽입하는 연산자
  - 주어진 인덱스에 해당하는 요소를 제거하는 연산자

- [실습보러가기](https://github.com/heejung-gjt/TIL/blob/master/Algorithm/Array_practice/array.py)   

  <br>

## 선형탐색(순차탐색)
순서대로 비교하면서 찾는다
```py
def linear_search(L,x):
  i = 0
  while i < len(L) and L[i] != x:
    i += 1
  if i < len(L):
    return i
  else:
    return -1
```

## 이진탐색
이미 정렬되어 있는 경우만 적용되는 탐색기법으로 반씩 쪼개어 비교하면서 찾는다
```py
def binary_arr(L, x):
    answer = 0
    lower = 0
    upper = len(L) - 1
    while lower <= upper:
        middle = (lower + upper) // 2
        if L[middle] == x:
            answer = middle
            return answer
        elif L[middle] < x:
            lower = middle + 1
        else:
            upper = middle - 1
    if lower > upper:
        return -1
```
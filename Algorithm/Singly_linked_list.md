## 연결리스트
연결리스트는 데이터와 다음 노드의 주소를 담고 있는 노드들이 한 줄로 연결되어 있는 방식의 자료구조이다         

```특징```    

- 연결리스트는 데이터 원소들을 순서를 지어 늘어놓는다는 점에서 배열과 비슷한점이 있다.     

- 연결리스트는 각 원소들을 줄줄이 엮어서 관리하는 방식이다    

- 연결리스트는 원소들이 링크라고 부르는 고리로 연결되어 있기 때문에 데이터를 삭제하거나 삽입하는것이 배열보다 쉽다(시간이 빠르다)      

- 자료의 순서는 정해져있으나 메모리상 연속성이 보장되지 않는다    

```장점```   
- 데이터 삽입이 간단하다   

- 항목 생성 후 포인터 값만 변경해주면 된다    

```단점```   
- 선형 배열에 비해 데이터 구조 표현에 소요되는 저장공간, 즉 메모리 소요가 크다. 데이터를 연결하는 링크도 메모리에 저장되어 있어야 하므로 메모리 요구량이 크다는 단점이 있다   

- 순차적으로 탐색되기 때문에 원하는 데이터를 찾기까지 더 오랜 시간이 걸리는 단점이 있다    


```자료구조 모습```    
연결리스트는 데이터를 노드의 형태로 저장한다. 노드에는 데이터와 다음 노드를 가르키는 포인터를 담은 구조로 이루어져 있다.    

<br>

## 단뱡향 연결 리스트(Singly linked list) 구현

그림과 같이 연결리스트는 각 노드에 자료공간과 한개의 포인터 공간이 있고 각 노드의 포인터는 다음 노드를 가리키는 역할을 한다 

![연결리스트](https://user-images.githubusercontent.com/64240637/114816078-665dc580-9df2-11eb-9640-d03f2bb2e279.png)

<br>

#### 연결리스트 구조   

```[1] 구조```   
데이터가 따로 떨어져 있기 때문에 다음 데이터와 연결된 노드를 가리켜줄 변수가 필요하다. 이를 next라는 변수로 이름을 지어준다. 맨 처음 노드를 가리킬것도 필요하므로 head라는 변수로 이름을 지어 가장 처음에 있는 노드가 어디에 있는지 저장한다    

##### 코드 구현
```python
class Node:
	def __init__(self, data, n=None):
		self.data = data  # 저장된 데이터
		self.next = n  # 다음 노드를 가리키는 변수 

class SingleLinkedList:
	def __init__(self):
		self.head = None # 첫 생성이 될땐 내부에 노드가 없으므로 첫노드를 가리키는 head의 값은 None이 된다
```

```[2] 삽입```    
연결리스트에서 데이터를 삽입할땐 head쪽에 노드를 추가하여 삽입한다.     

가장먼저 ```저장된 노드가 없는 경우``` head의 값은 None이다. 따라서 head에 새로 삽입되는 노드를 저장하고 next는 None이 된다         

```저장된 노드가 있는 경우``` 기존에 있는 노드는 밀려나고 새로운 노드가 들어온다. 즉 새로운 노드의 next에 현재 head값을 저장하고 head에는 새로운 노드를 저장시킨다 

##### 코드 구현
```python

def insert(self, value): # 삽입할 데이터 
	if self.head is None: # 만약 추가하려는 데이터가 첫 노드일 경우 현재 head는 None이다
		self.head = Node(value)
	else: # 이미 노드가 있는 경우
		# head에 새로운 노드를 저장하고 기존 head에 저장되었던 노드는 새로 생성할 노드의 next로 저장
		self.head = Node(value,self.head) 
```

```[3] 출력```
연결리스트는 head가 가리키는 노드부터 순차적으로 접근이 가능하다.   
head를 통해서 첫 노드에 접근하고 이후에 노드가 가지고 있는 변수 next를 통해서 다음 노드로 이동할 수 있다. 만약 next의 변수가 None이라면 해당 노드가 마지막 위치인것을 알 수 있다.    

```저장된 노드가 없을 경우``` 그대로 출력해주면 된다. 만약 ```저장된 노드가 있을 경우``` 가장 먼저 head가 가리키고 있는 node의 value값을 출력하고 변수 next가 none이 아니라면 next를 통해서 다음 노드로 이동하여 value를 출력한다. 이러한 과정을 next가 none일때까지 반복해준다   
##### 코드 구현
```python

def printNode(self):
	if self.head is None:
		print('저장된 데이터 없음')
		return
	else:
		link = self.head

		while link: 
			print(link.data)
			link = link.next
		print()
```

```[4] 삭제```
연결리스트에서 삭제하고 싶은 데이터의 경우 알아서 처리해주는 가비지 컬렉션 개념을 사용한다. 즉 삭제된 데이터의 메모리 해제는 신경쓰지 않아도 된다

```저장된 노드가 없을 경우```는 제외시켜준다. ```저장된 노드가 있을 경우``` head가 가리키고 있는 노드가 삭제된다. (파이썬에서는 메모리해제를 하지 않으므로 삭제라기보다는 관리에서 제외시킨다는 개념이 더 적합하다). head에 다음 노드를 가리키도록 변경하면 된다. 
##### 코드 구현
```python

def deleteNode(self):
	if self.head is None:
		print('삭제할 데이터 없음')
		return
	else:
		self.head = self.head.next
```

```[5] 탐색```
연결리스트에서 찾으려는 노드를 찾을때까지 이동한다. 찾으려는 노드를 찾게되면 노드가 몇번째인지를 반환하고 만약 찾지 못하면 none를 반환시킨다

```저장된 노드가 없을 경우```는 제외시켜준다. ```저장된 노드가 있을 경우``` 노드의 head가 none이 될때까지(끝까지) 반복해서 원하는 노드를 찾아준다. 이때 해당 노드의 self.head.value가 원하는 값과 같으면 인덱스를 반환해주고 아니면 next로 다음 노드로 이동하여 비교해준다. 이때 index의 값도 1 증가 시켜준다
##### 코드 구현
```python

def searchNode(self, data):
	if self.head is None:
		print('저장된 데이터 없음')
		return
	else:
		link = self.head # 처음엔 head를 지정해준다
		index = 0 # 찾으려는 노드의 인덱스
		while link:
			if link.data == data:
				return index
			else:
				link = link.next
				index += 1
```






### 네비게이이션 float로 구현해보기  

최종적으로 나와야 하는 화면 구현은 아래와 같다.

![nav](https://user-images.githubusercontent.com/64240637/108992226-6851b500-76dc-11eb-9333-4a23f7f241e8.png)

webcafe 옆으로 메인 nav들이 쭉 나열되어 있고 해당 메뉴를 선택하면 아래에 sub menu 내용이 쭉 나열되어 나온다. 보기편하게 나누어서 살펴보면 html에서는 ul.menu > [li.menu-item > <[a.menu-item-button(HTML에 대해) + ul.sub-menu sub-menu1 > {li>a}*3]>*6  즉, ul.menu 안에 li.menu-item 태그를 만들고 그 안에 HTML에 대해라는 문장이 있는 a태그를 만들고 형제 요소로 ul을 또다시 만들어준다. 즉 ul 안에 li , li 안에 ul 을 다시만들고 그 안에 li를 다시 만들어준다. 
아래에는 6개 중 2개만 작성했지만 모두 똑같이 작성해주면 된다


##### html 구현
```html
<nav class="navigation">
        <h2 class="a11y-hidden">메인 메뉴</h2>
        <ul class="menu">
          <li class="menu-item menu-act" tabindex="0">
            <a href="#" role="button" class="menu-item-button">HTML에 대해</a>
            <ul class="sub-menu sub-menu1">
              <li>
                <a href="#">HTML5 소개</a>
              </li>
              <li>
                <a href="#">레퍼런스 소개</a>
              </li>
              <li>
                <a href="#">활용예제</a>
              </li>
            </ul>
          </li>
          <li class="menu-item" tabindex="0">
            <a href="#" role="button" class="menu-item-button">CSS에 대해</a>
            <ul class="sub-menu sub-menu2">
              <li>
                <a href="#">CSS 소개</a>
              </li>
              <li>
                <a href="#">CSS2 VS CSS3</a>
              </li>
              <li>
                <a href="#">CSS 애니메이션</a>
              </li>
              <li>
                <a href="#">CSS Framework</a>
              </li>
            </ul>
          </li>
          .
          .

        </ul>
      </nav>
```
<br>

### ! 새로 안 사실

__1. a링크를 button처럼 쓸 수 있을까?__    

가능하다. ```a[role='button']```으로 role설정을 해주면 스크린리더에서는 해당 a링크를 링크로 읽지 않고 button으로서의 역할로 읽는다
<br>

html 마크업이 끝난 후 화면을 보면 아래와 같이 수직정렬로 문장들이 나열되어 있는 것을 볼 수 있다

![html](https://user-images.githubusercontent.com/64240637/108997025-799dc000-76e2-11eb-9b19-259660b79632.png)


<br>

이제 css로 스타일을 입혀주면 된다. 그전에  ```<h2 class="a11y-hidden">메인 메뉴</h2>```은 웹접근성을 위해서 필요한 태그이고 실제로 화면에서는 보이지 않게 적용시키기 위해 css에서 작업을 따로 해준다.   
간단하게 display:none을 하는 방법도 있지만 아예 날려주는 방법이 많이 쓰인다. position:absolute를 주고 top:-9999px로 화면 밖으로 날려주는 방식이다. 하지만 아래에서는 이와 같은 방식이 아닌 clip속성을 사용했다 (이유가 무엇일까..? 좀더 알아봐야 겠다)
다음과 같이 스타일을 입히면 위에서 보였던 h2 메인메뉴라는 단어가 사라진것을 볼 수 있다
```css
.a11y-hidden{
  background-color: red;
  position: absolute;
  width: 1px;
  height: 1px;
  margin: -1px;
  overflow: hidden;
  clip: rect(0 0 0 0);
  clip-path: polygon(0 0, 0 0, 0 0);
}
```
<br>

이제 css로 스타일을 입혀주면 아래와 같이 menu가 화면에 보여지는 것을 볼 수 있다.

![css](https://user-images.githubusercontent.com/64240637/108996881-4ce9a880-76e2-11eb-89e7-c48e55586e7e.png)

ul.menu는 li.menu-item과 형제 요소인 ul.submenu<총6개>를 감싸고 있다.     

float는 정렬이 필요한 자식요소에게 주어야 하므로 menu-item에 float:left를 준다.
 
```css
.menu{
  border-top: 2px solid #000;
  /* box-shadow: 0 -2px 0 0 #000; */
  background:#ce4827 linear-gradient(to bottom, #eaac2e 0%,#ce4827 35%,#ce4827 70%,#eaac2e 100%);
  border-radius: 0 0 5px 5px;
  height: 47px;
  padding-left: 225px;
}
.menu-item{
  float: left;
  border-left: 1px solid #fff;
  line-height: 45px;
}
.menu-item-button{
  padding: 2px 20px 0; 
  display: block;
  color: #fff;
  font-size: 1.6rem;
  font-weight: 700;
  text-shadow: 1px 1px 0 #000, -1px -1px 0 #000;
}
.menu-act .menu-item-button{
  color: #ff0;
  /* border-bottom: 2px solid #000; */
}
.menu-act .menu-item-button::after{
  content: "";
  display: block;
  background-color: #000;
  height: 2px;
  margin-top: -2px;
}
.sub-menu{
  background-color: pink;
  position: absolute;
  display: none;
}
.sub-menu1{
  display: block;
  top: 0;
  left: 0;
}

```

<br>

### ! 새로 안 사실

__2. box-shadow 사용법__         
```box-shadow: 10px 10px 5px 10px #444```      
 [h-offset] [v-offset] [blur] [spread] [color]    
 [그림자의 좌우 위치 설정-필수][그림자의 상하 위치설정-필수][그림자의 흐려짐 정도의 범위-선택][그림자의 크기-선택] [그림자색상-선택]

__1. text-shadow 사용법__         
다중 그림자 속성으로 텍스트에 두 개 이상의 그림자를 추가하려면 쉼표로 구분하여 추가하면된다.    

```text-shadow: 1px 1px 0 #000, -1px -1px 0 #000;```      

[offset-x][offset-y][blur-radius][color]   
[수평 그림자 위치-필수][수직 그림자 위치-필수][흐림반경-선택][그림자색-선택]    

__border의 역할을 box-shadow로도 가능하다__   
border-top:2px solid #000 == box-shadow: 0 -2px 0 0 #000
<br>

### ! 새로 안 사실
padding : 3px 3px 3px 3px ;    
 (시계방향으로 위->오른쪽->아래->왼쪽)     

padding : 3px 3px;    
(위아래, 좌우)    

padding : 3px 3px 3px;   
(위, 좌우, 아래)    
<br>

### ! 새로 안 사실   
white-space : 스페이스와 탭, 줄바꿈 자동 줄바꿈을 어떻게 처리할지를 정하는 속성이다.    
글자수가 해당 너비를 넘어서게 되면 자동으로 줄바꿈이 이루어지는데 이를 다음 속성으로 조절할 수 있다. 
아래 이미지의 서브메뉴를 white-space를 이용하여 한줄로 나타나게 할 수 있다 

![white](https://user-images.githubusercontent.com/64240637/109090989-46e1df00-7757-11eb-9de2-ae1aee19ff22.png)   

![white2](https://user-images.githubusercontent.com/64240637/109090992-48aba280-7757-11eb-8e08-d16c1d5a6fb6.png)

sub-menu는 ul.sub-menu > li > a를 감싸고 있는 ul태그이다.   
a태그에 HTML5 소개, 레퍼런스 소개 문장들이 각각 들어가 있다   

```css
.sub-menu{
  position: absolute;
  display: none;
  top: 47px;
  white-space: nowrap;
}
```
이때 HTML소개 문장들을 수평정렬 해주는 것은 sub-menu li의 인라인 블록이다.  
ul에 nowrap을 주는 이유는 menu-item-button 즉 HTML에 대해를 감싸고 있는 태그의 너비를 넘기 때문에 줄바꿈이 일어나는데 이를 방지하기 위해서 주는 것이다.    
```css
.sub-menu li{
  display: inline-block;
}
```
<br>

hover과 focus를 이용하면 마우스를 해당 태그에 가져다 대었을때 (hover) color가 변경되며 해당 태그를 눌렀을때(focus) color가 변한 뒤 해당 color로 유지된다.

![hover](https://user-images.githubusercontent.com/64240637/109091646-86f59180-7758-11eb-9a31-e50801c9d9f8.png)

```css
.sub-menu a:hover, .sub-menu a:focus{
  color: #f00;
}
```

<br>

__애니메이션 이용해서 background 동적으로 처리하기__    

아래의 이미지 마크업은 간단하다. Web~ 문장만 div 안에 넣어주었다. 나머지는 Css에서 애니메이션 동작을 하는 속성을 이용하여 꽃들을 교차적으로 보이게 구현하고 web~ 문장이 오른쪽 상단에서 왼쪽 하단으로 점점 진해지면서 날라오게 구현하였다.    

```text
애니메이션 액션   

1. 이동효과 (오른쪽 상단 -> 왼쪽 하단) 
2. 글자크기
3. 투명도 
```

```html
 <div class="visual">
      <div class="visual-text">
        Web Standards &amp; Accessibility
      </div>
    </div>
```
![bg](https://user-images.githubusercontent.com/64240637/109091933-0b481480-7759-11eb-8b55-319a407b4f82.png)


<br>
css에서 사용한 속성은 @keyframes이다. 

```css
@keyframes textAni{
  0%{
    font-size: 12px;
    color: rgba(0,0,0,0);
    transform: translate(0, 0);
  }
  100%{
    font-size: 24px;
    color: rgba(0,0,0,1);
    transform: translate(400px, 75px);
  }
}
@keyframes bgAni{
  0%{
    opacity: 1;
  }
  100%{
    opacity: 0;
  }
}
.visual{
  height: 120px;
  position: relative;
}
.visual::before, .visual::after{
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-repeat: no-repeat;
  animation-name: bgAni;
  animation-duration: 2000ms;
  animation-iteration-count: infinite;
  animation-direction: alternate;
}
.visual::before{
  background-image: url(./images/ani_flower_01.png), url(./images/ani_flower_02.png);
  background-position: 0 -10px, 670px 0; 
}
.visual::after{
  background-image: url(./images/ani_flower_03.png), url(./images/ani_flower_04.png);
  background-position: 300px 0, 800px 0;
  animation-delay: 1000ms; 
}
.visual-text{
  font-family: Georgia, 'Times New Roman', Times, serif;
  position: absolute;
  z-index: 10;
  animation-name: textAni;
  animation-duration: 1000ms;
  animation-fill-mode: forwards;
}
```
<br>

### ! 새로 안 사실   
애니메이션 문장에 이동 효과를 주면 문장이 들어가 있는 태그는 div태그이므로 block 으로 설정되어 있다. 즉, 해당 박스를 벗어나기 때문에 아래에 원치않는 스크롤 바가 생기게 된다. 이를 방지하기 위해 
여러 방법으로 해결할 수 있다    

해결을 position:absolute를 주어 해결하였지만 display로 속성을 inline-block으로 바꾸어 해결할 수도 있다

```css
.visual-text{
  position: absolute;
  /* display: inline-block; */
  z-index: 10;
  animation-name: textAni;
  animation-duration: 1000ms;
  animation-fill-mode: forwards;
}
```
<br>

__배경이미지 교차 편집__
html에 여러 상자를 겹쳐 absolute를 주어서 번갈아가며 보이게 할수도 있지만 여기서는 css의 가상 선택자를 이용해서 구현했다. before와 after에 다른 image를 넣어주고 dealy를 주어 화면에 보이는 시간의 차이를 주었다. 
```css
.visual::before, .visual::after{
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-repeat: no-repeat;
  animation-name: bgAni;
  animation-duration: 2000ms;
  animation-iteration-count: infinite;
  animation-direction: alternate;
}

@keyframes bgAni{
  0%{
    opacity: 1;
  }
  100%{
    opacity: 0;
  }
}

.visual::before{
  background-image: url(./images/ani_flower_01.png), url(./images/ani_flower_02.png);
  background-position: 0 -10px, 670px 0; 
}
.visual::after{
  background-image: url(./images/ani_flower_03.png), url(./images/ani_flower_04.png);
  background-position: 300px 0, 800px 0;
  animation-delay: 1000ms; 
}
```
 #### 👉 함수
함수를 정의해보면 함수란 __일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것__ 이다.    

함수는 아래와 같이 작성이 된다
 ```javascript
 function add(x,y){
     return x + y;
 }
 add(2,5);
 ```
 함수 내부로 입력을 전달받는 변수를 ```매개변수```, 입력을 ```인수```, 출력을 ```반환값```이라고 한다.   

__인수는 매개변수에 할당되어지고 각각의 인수는 자바스크립트 엔진에 의해 값이 평가되어 결과가 나오기 때문에 표현식이라고 할 수 있다.__  함수에 return을 써주지 않으면 암묵적으로 함수는 return을 해주게 되기 때문에 undefined가 된다    

```add(2,5) = 표현식```  
```text
//함수정의 
function add(x,y){
    return x+y;
}

//함수이름(네이밍이 중요하다. 의미있게 지어준다)
add

//매개변수(==인자, 파라미터, 매개변수)
(x,y)

//반환값
return x+y;

//함수호출
add(2,5);

//인수
(2,5)
```

<br>

 #### 👉 함수 네이밍
 ```변수```는 주로 __명사__ 로 네이밍 되어진다  
```함수```는 명령형인 __동사__로 네이밍 되어진다   

<br>

 #### 👉 함수 선언문(함수생성방법1)
 함수 선언문은 런타임 이전에 실행이 되기 때문에 항상 가장 먼저 선언이 되어진다. 함수 선언문은 함수 이름을 생략 할 수 없으며 표현식이 아닌 문이다. 
 ```javascript
 function add(x,y){
     return x + y;
 }
 ```

 <br>

 #### 👉 함수 표현식(함수생성방법2)
 함수의 선언문에 변수를 선언해주면 이제 해당 함수는 선언문이 아닌 표현식이 된다. 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.    

 아래의 코드를 보면 함수는 함수 이름 add로 호출하는 것이 아닌 함수 객체를 가리키는 식별자 adds로 호출한다.     

 함수 표현식에서는 function add(x,y)인 함수리터럴의 함수 이름인 add를 생략한다. 
 ```javascript
 var adds = function add(x,y){
     return x + y;
 };

 console.log(adds(2,5));  // 7

 var adds = function(x,y){
     ...
 } // 함수이름 생략 가능
 ``` 
 #### 👉 함수 리터럴
 함수 리터럴은 함수 표현식이라고 할 수 있으며 함수 객체를 표현한다   

 <br>

  #### 👉 함수 호이스팅
함수 호이스팅은 변수 호이스팅과 다른점이 있다. 둘다 런타임 이전에 식별자를 먼저 생성하는 것은 동일하지만 변수 호이스팅은 해당 변수가 undefined로 초기화되고 함수 호이스팅은 함수 선언문을 통해 암묵적으로 함수 객체로 초기화 한다. 

함수 선언문으로 정의된 함수는 런타임 이전에 실행되기 때문에 모든 console.log가 에러없이 정상 출력되는 것을 볼 수 있다  

  ```함수 선언문```
  ```javascript
  console.log(add(1,2)); //3

  function add(x,y){
      return x+y;
  }
  console.log(add(3,4)); //7
  ```
함수 표현식으로 선언한 함수는 변수 선언인 var add가 런타임 전에 실행되어 undefined로 초기화되지만 변수 할당문의 값은 런타임에 평가되어 함수리터럴은 할당문이 실행되는 런타임에 평가되어 함수 객체가 된다. __즉 함수 표현식으로 함수를 정의하게 되면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다__
```함수 표현식```
```javascript
console.log(add(1,2)); //error발생
var add = function(x,y){
    return x+y;
console.log(add(3,4));  // 7
}
```

<br>

  #### 👉 일반객체와 함수객체
  ```일반객체``` : 객체를 호출할 수 없다   
  ```함수객체``` : 객체를 호출할 수 있다   

<br>

  #### 👉 파라미터와 알규먼트
  ```파라미터``` : 파라미터는 다른말로 __매개변수__ , __인자__ 라고 불린다.   
  ```알규먼트``` : 알규먼트는 다른말로 __인수__ 라고 불린다   
  함수를 실행하기 위해 필요한 값을 함수 내부로 전달하기 위해서는 매개변수를 통해 인수를 전달한다. 이때 인수는 값으로 평가될 수 있는 표현식이어야 한다.     

<br>

#### 👉 arguments 객체
arguments 객체는 함수를 정의 할 때 매개변수 개수를 알 수 없는 가변 인자 함수를 구현할때 사용된다. 객체를 배열처럼 쓸 수 있다.

```javascript
function add(){
    console.log(arguments);
}
add(2,5,6); // [Arguments] { '0': 2, '1': 5, '2': 6 }
```

<br>

#### 👉 가변인자 함수
arguments를 이용해주는 것도 좋지만 args인 가변인자를 이용해주는 것이 모던한 방법이다. 결과는 배열로 출력되는 것을 볼 수 있다 
```javascript
function add(...args){
    console.log(args);
}
add(2,5,6); // [ 2, 5, 6 ]
```

<br>

#### 👉 참조에 의한 전달과 외부 상태 변경   
함수를 호출하면서 매개변수에 값을 전달하는 방법이 2가지가 있다 ```값에 의한 호출```      ```참조에 의한 호출``` 

원시값인 age는 값 자체가 복사되기 때문에 원본이 훼손되지 않지만 객체인 name은 참조값이 복사되어 전달되므로 원본이 훼손된다
  
```javascript
function infor(name, age){
    name = 'hee';
    age = 24;
}

var name = {name:'jung'};
var age = 30;

infor(name,age); 

console.log(age); // 30 원본훼손 x
console.log(name) // {name:'jung'} 원본훼손 o
```

<br>                

#### 👉 즉시 실행 함수
전역변수는 사용하지 않는 것이 좋다. 따라서 즉시 실행함수를 사용하여 지역변수로 만들어 사용하는 것을 권장한다. 즉시 실행함수는 함수 이름 없이 사용한다.(함수 이름이 있는 기명 즉시 실행함수 사용 가능) 따라서 해당 함수는 다시 호출할 수 없다   
```javascript  
(function (){  // 익명 즉시 실행 함수
    var a = 1;
    var b = 2;
    return a * b
})();


(function mul(){  // 기명 즉시 실행 함수
    var a = 1;
    var b = 2;
    return a * b
})();

mul(); // error
```

<br>

#### 👉 중첩 함수
함수내부에 정의된 함수를 ```중첩함수``` 또는 ```내부함수``` 라고 한다. 중첩함수를 포함하는 함수는 ```외부함수```라 부른다   

중첩함수가 쓰이는 이유는 외부함수에서만 실행되기 위한 함수를 만들기 위해서이다. (--> 스코프와 클로저에 깊은 관련있음 나중에 참고하기)
```javascript
function out(){
  var x = 1;
  
  function in(){  //중첩함수
      var y = 2;
      console.log(x + y); //3
  }

  in();
    
}
out();
```

<br>

#### 👉 콜백 함수

 #### 👉 함수
함수를 정의해보면 함수란 __일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것__ 이다.    

함수는 아래와 같이 작성이 된다
 ```javascript
 function add(x,y){
     return x + y;
 }
 add(2,5);
 ```
 함수 내부로 입력을 전달받는 변수를 ```매개변수```, 입력을 ```인수```, 출력을 ```반환값```이라고 한다.   

__인수는 매개변수에 할당되어지고 각각의 인수는 자바스크립트 엔진에 의해 값이 평가되어 결과가 나오기 때문에 표현식이라고 할 수 있다.__  함수에 return을 써주지 않으면 암묵적으로 함수는 return을 해주게 되기 때문에 undefined가 된다    

```add(2,5) = 표현식```  
```text
//함수정의 
function add(x,y){
    return x+y;
}

//함수이름(네이밍이 중요하다. 의미있게 지어준다)
add

//매개변수(==인자, 파라미터, 매개변수)
(x,y)

//반환값
return x+y;

//함수호출
add(2,5);

//인수
(2,5)
```

<br>

 #### 👉 함수 네이밍
 ```변수```는 주로 __명사__ 로 네이밍 되어진다  
```함수```는 명령형인 __동사__로 네이밍 되어진다   

<br>

 #### 👉 함수 선언문(함수생성방법1)
 함수 선언문은 런타임 이전에 실행이 되기 때문에 항상 가장 먼저 선언이 되어진다. 함수 선언문은 함수 이름을 생략 할 수 없으며 표현식이 아닌 문이다. 
 ```javascript
 function add(x,y){
     return x + y;
 }
 ```

 <br>

 #### 👉 함수 표현식(함수생성방법2)
 함수의 선언문에 변수를 선언해주면 이제 해당 함수는 선언문이 아닌 표현식이 된다. 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.    

 아래의 코드를 보면 함수는 함수 이름 add로 호출하는 것이 아닌 함수 객체를 가리키는 식별자 adds로 호출한다.     

 함수 표현식에서는 function add(x,y)인 함수리터럴의 함수 이름인 add를 생략한다. 
 ```javascript
 var adds = function add(x,y){
     return x + y;
 };

 console.log(adds(2,5));  // 7

 var adds = function(x,y){
     ...
 } // 함수이름 생략 가능
 ``` 
 #### 👉 함수 리터럴
 함수 리터럴은 함수 표현식이라고 할 수 있으며 함수 객체를 표현한다   

 <br>

  #### 👉 함수 호이스팅
함수 호이스팅은 변수 호이스팅과 다른점이 있다. 둘다 런타임 이전에 식별자를 먼저 생성하는 것은 동일하지만 변수 호이스팅은 해당 변수가 undefined로 초기화되고 함수 호이스팅은 함수 선언문을 통해 암묵적으로 함수 객체로 초기화 한다. 

함수 선언문으로 정의된 함수는 런타임 이전에 실행되기 때문에 모든 console.log가 에러없이 정상 출력되는 것을 볼 수 있다  

  ```함수 선언문```
  ```javascript
  console.log(add(1,2)); //3

  function add(x,y){
      return x+y;
  }
  console.log(add(3,4)); //7
  ```
함수 표현식으로 선언한 함수는 변수 선언인 var add가 런타임 전에 실행되어 undefined로 초기화되지만 변수 할당문의 값은 런타임에 평가되어 함수리터럴은 할당문이 실행되는 런타임에 평가되어 함수 객체가 된다. __즉 함수 표현식으로 함수를 정의하게 되면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다__    

```함수 표현식```
```javascript
console.log(add(1,2)); //error발생
var add = function(x,y){
    return x+y;
console.log(add(3,4));  // 7
}
```

<br>

  #### 👉 일반객체와 함수객체
  ```일반객체``` : 객체를 호출할 수 없다   
  ```함수객체``` : 객체를 호출할 수 있다   

<br>

  #### 👉 파라미터와 알규먼트
  ```파라미터``` : 파라미터는 다른말로 __매개변수__ , __인자__ 라고 불린다.   
  ```알규먼트``` : 알규먼트는 다른말로 __인수__ 라고 불린다   
  함수를 실행하기 위해 필요한 값을 함수 내부로 전달하기 위해서는 매개변수를 통해 인수를 전달한다. 이때 인수는 값으로 평가될 수 있는 표현식이어야 한다.     

<br>

#### 👉 arguments 객체
arguments 객체는 함수를 정의 할 때 매개변수 개수를 알 수 없는 가변 인자 함수를 구현할때 사용된다. 객체를 배열처럼 쓸 수 있다.

```javascript
function add(){
    console.log(arguments);
}
add(2,5,6); // [Arguments] { '0': 2, '1': 5, '2': 6 }
```

<br>

#### 👉 가변인자 함수
arguments를 이용해주는 것도 좋지만 args인 가변인자를 이용해주는 것이 모던한 방법이다. 결과는 배열로 출력되는 것을 볼 수 있다 
```javascript
function add(...args){
    console.log(args);
}
add(2,5,6); // [ 2, 5, 6 ]
```

<br>

#### 👉 참조에 의한 전달과 외부 상태 변경   
함수를 호출하면서 매개변수에 값을 전달하는 방법이 2가지가 있다 ```값에 의한 호출```      ```참조에 의한 호출``` 

원시값인 age는 값 자체가 복사되기 때문에 원본이 훼손되지 않지만 객체인 name은 참조값이 복사되어 전달되므로 원본이 훼손된다
  
```javascript
function infor(name, age){
    name = 'hee';
    age = 24;
}

var name = {name:'jung'};
var age = 30;

infor(name,age); 

console.log(age); // 30 원본훼손 x
console.log(name) // {name:'jung'} 원본훼손 o
```

<br>                

#### 👉 즉시 실행 함수
전역변수는 사용하지 않는 것이 좋다. 따라서 즉시 실행함수를 사용하여 지역변수로 만들어 사용하는 것을 권장한다. 즉시 실행함수는 함수 이름 없이 사용한다.(함수 이름이 있는 기명 즉시 실행함수 사용 가능) 따라서 해당 함수는 다시 호출할 수 없다   
```javascript  
(function (){  // 익명 즉시 실행 함수
    var a = 1;
    var b = 2;
    return a * b
})();


(function mul(){  // 기명 즉시 실행 함수
    var a = 1;
    var b = 2;
    return a * b
})();

mul(); // error
```

<br>

#### 👉 중첩 함수
함수내부에 정의된 함수를 ```중첩함수``` 또는 ```내부함수``` 라고 한다. 중첩함수를 포함하는 함수는 ```외부함수```라 부른다   

중첩함수가 쓰이는 이유는 외부함수에서만 실행되기 위한 함수를 만들기 위해서이다. (--> 스코프와 클로저에 깊은 관련있음 나중에 참고하기)
```javascript
function out(){
  var x = 1;
  
  function in(){  //중첩함수
      var y = 2;
      console.log(x + y); //3
  }

  in();
    
}
out();
```

<br>

#### 👉 콜백 함수

repeat함수는 매개변수의 크기만큼 console.log를 반복한다. 이때 repeat함수는 console.log만을 반복하며 다른일을 할 수가 없는 상태이다. 
```javascript
function repeat(n){
    for(var i = 0; i < n; i++>){
        cosole.log(i);
    }
}
repeat(5);
```
아래의 코드에서는 함수의 매개변수를 통해 다른 기능을 하는 함수를 전달하였다. 이처럼 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 ```콜백함수```라고 하고 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수(outputAll,outputOdd)를 ```고차함수```라고 한다 
```javascript
function repeat(n,f){
    for(var i = 0; i < n; i++){
        f(i);
    }
}
var outputAll = function(i){
    console.log(i);
};

repeat(5,outputAll); //0,1,2,3,4

var outputOdd = function(i){
    if(i % 2) console.log(i);
};

repeat(5,outpuOdd); // 1, 3
```

이때 콜백함수가 고차 함수 내부에서만 호출된다면 콜백 함수를 익명함수 리터럴로 정의하여 고차 함수에 곧바로 전달하는 것이 일반적이다   


익명 함수 리터럴을 콜백함수로 고차함수에 전달하고 repeat 함수를 호출할 때마다 평가되어 함수 객체를 생성한다

##### 예1)
```javascript
repeat(5,function(i){
    if(i%2){
        console.log(i);
    }
};

```
아래 코드는 콜백 함수를 이용하여 이벤트처리를 한 과정이다. button 버튼을 클릭하면 콜백함수가 실행이 되어 console.log가 실행된다
##### 예2)
```javascript
document.getElementById('button').addEventListener('click',function(){
    console.log('button clicked');
});
```

<br>

#### 👉 순수함수와 비순수 함수

```순수함수``` : 외부 상태에 의존하지 않고 변경하지 않는 즉, 부수 효과가 없는 함수를 순수함수라고 한다    

아래의 함수는 순수함수로 increase는 동일한 인수가 들어오게 되면 항상 동일한 값을 반환하게 된다

```javascript
var count = 0;

function increase(n){
    return ++n;
}
count = increase(count);
console.log(count);
```
```비순수함수``` : 외부 상태에 따라 반환값이 달라지는 즉 외부 상태에 의존하는 함수를 비순수함수라고 한다
순순 함수와 다른 특징은 함수의 외부 상태를 변경하는 부수효과가 있다. (함수 외부 상태의 변경을 지양하는 순수함수 사용을 권장한다, 비순순함수는 상태의 변화를 추적하기도 어렵고 코드의 복잡성을 증가시킨다)

```javascript
var count = 0;

function increase(){
    return ++count;
}
// increase에 따라 외부에 있는 Count의 값이 변경된다 
increase();
console.log(count); //1

increase();
console.log(count); //2
```
<br>


#### 👉 스코프
모든 식별자는 자신이 선언된 위치에 따라 다른 코드가 자신을 참조할수 있는 유효범위가 결정된다. 이를 ```스코프```라고 한다. 스코프 내에서 식별자는 유일해야 한다. 하지만 다른 스코프에는 같은 이름의 식별자를 사용할 수 있는데 이를 ```네임스페이스```라고 한다    

```네임스페이스``` :  하나의 이름 공간에서는 하나의 이름이 단 하나의 개체만을 가리키게 된다 

var키워드와 let,const키워드로 선언한 변수의 스코프는 다르게 동작한다    

매개변수 x와y는 add함수 내부에서만 유효한 변수이다 즉, 스코프는 함수 내부이다

```javascript
function add(x,y){
    console.log(x,y); //2 5
    return x + y;
}

add(2,5);  //error

console.log(x,y)
```

아래코드를 보면 var1=2와 var1=3은 if 코드 블록 내에서 선언되었지만 전역에서 선언한것과 마찬가지로 사용이 되기 때문에 호이스팅으로 차례대로 1,2,3으로 재할당이 되어 최종적으로 3이 출력된다
```javascript
var var1 = 1; 

if (true) {
  var var1 = 2;
  if (true) {
    var var1 = 3; 
  }
}
consle.log(var1); //3
```
<br>

#### var 키워드로 선언한 변수의 중복 선언
var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용되는 단점이 있다. 따라서 let과 const사용을 장하는데 let의 사용을 지양하고 const의 사용을 지향한다.    

<br>

#### 스코프 실행 순서   


```javascript
var x = 1;

function foo(a){
    var y = 2;
    console.log(x);
};

foo(100);
```

__(1)__     
위와 같은 코드의 실행순서는 var x가 런타임전에 선언되어지고 초기화값으로 undefined가 선언된다. 함수 foo의 선언문도 런타임전에 선언되어진다. 메모리상에 x라는 변수의 값 undefined가 할당되고 foo라는 함수객체가 할당된다        

[전역변수 scope]    

|키|값|
|--|--|
|x|undefined|
|foo|function|    


__(2)__   
런타임이 실행되면서 x에 1이 할당되고 foo함수 알규먼트로 100이 할당되어지고 전역 변수에서 foo함수를 찾는다    

[전역변수 scope]   

|키|값|
|--|--|
|x|1|
|foo|function(100)|   

__(3)__   
함수 foo안의 런타임 전에 a와 y가 먼저 선언되어진다. undenfined로 초기화가 된다    

[foo함수 scope]   

|키|값|
|--|--|
|a|undefined|
|y|undefined|   

__(4)__   
이후 함수안의 런타임이 실행되면서 a와 y에 값을 할당한다        

[foo함수 scope]   

|키|값|
|--|--|
|a|100|
|y|2|   

__(5)__   
함수안에 있는 console.log(x)를 실행하는데 X의 값을 먼저 foo함수 scope에서 찾는다. 만약 X의 값이 없는 경우 상위 스코프로 올라가 X의 값을 찾게 된다 즉, 모든 스코프는 하나의 계층적 구조로 연결되며 이러한 구조를 ```스코프체인```이라고 한다     

cosole.log(x)의 값 = 1

[전역변수 scope]   

|키|값|
|--|--|
|x|1|
|foo|function(100)|    

^   
^   
^   

[foo함수 scope]   

|키|값|
|--|--|
|a|100|
|y|2|   

<br>

#### 👉 블록/함수 레벨 스코프
지역은 지역 스코프를 만드는데 이는 코드블록이 아닌 함수에 의해서만 지역 스코프가 생성된다는 의미이다. 이때 함수의 몸체뿐만이 아니라 모든 코드블록(if,for,while,try/catch)도 지역 스코프를 만든다. 이를 ```블록레벨스코프```라고 한다. 하지만 __var키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역스코프로 인정한다__ 이를 ```함수레벨 스코프``` 라고 한다.     

아래의 코드는 var키워드로 선언이 되어졌기 때문에 함수레벨 스코프로 함수의 코드블록 만을 지역스코프로 인정하고 나머지는 전역변수로 처리하기 때문에 X=10이 최종적인 값이 된다

```javascript
var x = 1;

if(true){
  
  var x = 10;

}
console.log(x); // 10


```

<br>

#### 👉 렉시컬 스코프

```javascript
var a = 10;

function add() {
  var a = 100;
  mul();
}

function mul() {
  console.log(a);
}

add();  //10
mul();  //10
```
위의 코드를 실행결과는 mul의 상위 스코프가 무엇이냐에 따라 결과가 달라지는데 두가지의 경우가 있다   

1. __함수를 어디서 호출했는지__ 에 따라 함수의 상위 스코프를 결정   

2. __함수를 어디서 정의했는지__ 에 따라 함수의 상위 스코프를 결정   

첫번째 방식을 동적 스코프라고 하며 mul함수의 상위 스코프는 add 함수 안의 스코프가 될것이다.   

두번째 방식을 렉시컬 스코프라고 하며 mul 함수의 상위 스코프는 전역 스코프가 될것이다.    

이때 자바스크립트는 두번째 방식인 렉시컬 스코프를 따르고 있기 때문에 함수를 어디서 정의했는지에 따라 상위 스코프를 결정하게 된다

<br>

#### 👉 전역/지역 변수

```전역변수 문제점```   
1. 전역 변수의 생명 주기가 매우길어 메모리를 낭비한다.   

2. 전역 변수를 선언한 변수는 코드 어디에서든지 값을 찾조하고 할당하며 변경할 수 있게 되는 암묵적 결합을 허용하여 코드의 가독성을 나쁘게 만든다.   

3. 전역 변수는 스코프 체인상에서 종점에 존재하기 때문에 가장 마지막에 검색이 되어 속도가 가장 느리다.   

4. 다른 파일에 동일한 이름으로 지어진 전역 변수나 함수가 같은 스코프에 존재할 경우 예상치 못한 결과를 가져올 수 있다.   

#### 전역 변수의 사용을 억제하는 방법
전역 변수를 지양해야 하는데 사용행 할 경우 즉시실행함수를 이용한다. 즉 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시실행 함수의 지역변수가 된다. 

```javascript
(function(){
    var foo = 10;
})();

console.log(foo); //error
```

전역변수를 안쓰는 방법에서 가장 모던한 방법은 모듈패턴을 사용하는 것이다. 모듈 패턴에 대해선 다음에 알아보자    

<br>

#### 👉 var ,let, const

```var키워드 문제점```    
1. 중복 사용 허용   
2. 함수 레벨 스코프만 지원   
3. 변수 호이스팅 선언 가능   

```let, const 장점```   
1. 중복 사용 허용 X   
2. 블록 레벨 스코프 지원   
3. 변수 호이스팅이 발생하지만 발생하지 않은 것처럼 보인다    

let은 재할당이 가능하지만 const는 재할당이 불가능하며 반드시 첫 할당을 해주어야 한다.   
변수를 선언할때 변수 값이 객체이건 상관없이 const로 선언해준뒤 필요에 따라 let으로 변경하여 사용하는 것을 권장한다.   

#### 변수와 상수
상수는 변수의 한 종류로, 재할당이 금지된 변수이다. 원시값이 할당되었을때 재할당이 불가능하기 때문에 해당값을 유지한다   
